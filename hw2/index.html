<html>
<head>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        h1 { text-align: center; }
        .container { margin: 0 auto; padding: 60px 20%; }
        figure { text-align: center; }
        img { display: inline-block; }
        body { font-family: 'Inter', sans-serif; }
    </style>
</head>
<body>
<div class="container">
    <h1>CS184/284A Summer 2025 Homework 2 Write-Up</h1>
    <div style="text-align: center;">Names: Muze Du</div>

    <br>
    Link to webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-Smoossy/hw2/index.html">webpage</a><br>
    Link to GitHub repository: <a href="https://github.com/cal-cs184/hw2-meshedit-hachimi/tree/Smoossy-patch-1">repos</a>

    <figure>
        <img src="17.png" alt="Teapot" style="width:50%" />
    </figure>

    <h2>Overview</h2>
    This project implements 2D and 3D Bézier curves (though 3D failed on this device due to an unknown issue) and explores triangle mesh editing using the half-edge data structure. We can now perform operations such as edge splitting, edge flipping, and more complex procedures like Loop subdivision.

    <h2>Section I: Bézier Curves and Surfaces</h2>

    <h3>Part 1: Bézier Curves with 1D de Casteljau Subdivision</h3>
    <p>De Casteljau subdivision is a straightforward way to generate Bézier curves using multiple control points. By recursively calculating weighted averages between neighboring control points based on \( t \), we ultimately arrive at a single point on the curve. I implemented this using a loop that reduces the number of points each iteration, terminating when only one point remains.</p>
    <div style="display: flex; flex-direction: column; align-items: center;">
        <img src="1.png" width="400px" />
        <div style="display: flex; flex-direction: row;">
            <img src="18.png" width="300px" />
            <img src="19.png" width="300px" />
        </div>
        <div style="display: flex; flex-direction: row;">
            <img src="20.png" width="300px" />
            <img src="21.png" width="300px" />
        </div>
    </div>

    <h3>Part 2: Bézier Surfaces with Separable 1D de Casteljau</h3>
    <p>Bézier surfaces extend the concept of Bézier curves. First, we compute intermediate control points along one axis using parameter \( u \), then repeat the process along the second axis using \( v \), producing a final point on the surface. I used two nested loops to perform these evaluations.</p>
    <div style="text-align: center;">
        <img src="2.png" width="400px" />
        <figcaption>The bez teapot.</figcaption>
    </div>

    <h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

    <h3>Part 3: Area-Weighted Vertex Normals</h3>
    <p>To compute area-weighted vertex normals, we first calculate the normal vector for each face surrounding a vertex:</p>
    <p style="text-align: center;">\( \text{norm} = \sqrt{\text{cross}(\vec{v_1}, \vec{v_2})} \)</p>
    <p>Then, we calculate the area of each face:</p>
    <p style="text-align: center;">\( \text{area} = \sqrt{\text{dot}(\vec{v_1}, \vec{v_1}) \cdot \text{dot}(\vec{v_2}, \vec{v_2}) - \text{dot}(\vec{v_1}, \vec{v_2})^2} \)</p>
    <p>Finally, we weight each normal by its area and normalize. I used a brute-force method that computes each vertex separately, which leads to some redundant calculations. This technique is similar to texture mapping, where the renderer shades each point based on vertex normals.</p>
    <div style="display: flex; flex-direction: row;">
        <img src="3.png" width="400px" />
        <img src="4.png" width="400px" />
    </div>
    <figcaption>before, after</figcaption>

    <h3>Part 4: Edge Flip</h3>
    <p>Edge flipping is relatively simple compared to edge splitting. No new elements need to be created—just reassign existing half-edge, vertex, edge, and face pointers. The key is to update the half-edges first, then the vertices, followed by the edges and faces.</p>
    <div style="display: flex; flex-direction: row;">
        <img src="5.png" width="400px" />
        <img src="6.png" width="400px" />
    </div>

    <h3>Part 5: Edge Split</h3>
    <p>This part was challenging—it took nearly 80 lines of code to correctly reassign all pointers. In addition to the strategy used in edge flipping, I created a diagram to help visualize what needed to be created and where to point. Any misassignment can cause crashes, missing faces, or issues in subsequent steps.</p>
    <div style="text-align: center;">
        <img src="splitedge.png" width="300px" />
    </div>
    <div style="display: flex; flex-direction: row;">
        <img src="7.png" width="300px" />
        <img src="8.png" width="300px" />
        <img src="9.png" width="300px" />
    </div>
    <figcaption>before, after, after</figcaption>

    <h3>Part 6: Loop Subdivision for Mesh Upsampling</h3>
    <p>Building on the previous steps, Loop subdivision becomes straightforward. First, we traverse each vertex to compute its new position based on neighboring vertices. Then, for each split edge, we compute a weighted new position using adjacent vertices. After splitting all edges and flipping each new edge between a new and an old vertex, we assign the precomputed new positions. The resulting mesh is smoother, with softened corners and edges.</p>
    <p>However, as subdivision continues, the cube starts to resemble a lemon shape. Not all vertices have the same degree. To improve symmetry, we can pre-split all edges on each face, ensuring uniform vertex degrees.</p>
    <div style="text-align: center;">
        <img src="13.png" width="500px" />
        <figcaption>Just like this.</figcaption>
        <img src="14.png" width="500px" />
        <figcaption>After dividing, the cube remains symmetric.</figcaption>
    </div>
    <p>By pre-splitting edges, we can also preserve sharp features in specific parts of the mesh.</p>
    <div style="text-align: center;">
        <img src="15.png" width="400px" />
        <img src="16.png" width="400px" />
    </div>
</div>
</body>
</html>